#include <cupy/carray.cuh>


template<typename FT, typename CT>
__device__ __forceinline__ CT
mul_CT_FT(FT floatval, CT complexval)
{
    return {floatval * complexval.x, floatval * complexval.y};
}

__device__ __forceinline__ {{coords_type}}
factorial(unsigned n)
{
    if(n == 0)
        { return 1.0; }

    {{coords_type}} fac = 1;

    for(int i = 1; i <= n; i++)
        { fac *= i; }

    return fac;
}

__device__ __forceinline__ {{coords_type}}
pre_fac(int k, int n, int m)
{
    {{coords_type}} numerator = factorial(n - k);

    if(k % 2 == 1)
        { numerator *= -1; }

    {{coords_type}} denominator = factorial(k) *
                                 factorial((n+m)/2.0 - k) *
                                 factorial((n-m)/2.0 - k);

    return numerator / denominator;
}

__device__ __forceinline__ {{coords_type}}
zernike_rad(int m, int n, {{coords_type}} rho)
{
    {{coords_type}} radial_component = 0.0;

    for(int k = 0; k < ((n - m) / 2) + 1; k++)
    {
        radial_component += pre_fac(k, n, m) *
                            {{pow_fn}}(rho, n - 2.0 * k);
    }

    return radial_component;
}

__device__ __forceinline__ {{coords_type}}
zernike(int j, {{coords_type}} rho, {{coords_type}} phi)
{
    if(rho >= 1)
        { return 0.0; }

    // Convert from Noll to regular dual index
    int n = 0;
    j += 1;
    int j1 = j - 1;

    while(j1 > n)
    {
        n += 1;
        j1 -= n;
    }

    int m = ((n % 2) + 2 * ((j1 + ((n + 1) % 2)) / 2));

    if(j % 2 == 1)
        { m *= -1; }

    // Evaluate Zernike polynomials
    if(m > 0)
    {
        return zernike_rad(m, n, rho) * {{cos_fn}}(m * phi);
    }
    else if(m < 0)
    {
        return zernike_rad(-1 * m, n, rho) * {{sin_fn}}(-1 * m * phi);
    }

    return zernike_rad(0, n, rho);
}

{%- set nsrc = "coords.shape()[1]" %}
{%- set ntime = "coords.shape()[2]" %}
{%- set na = "coords.shape()[3]" %}
{%- set nchan = "coords.shape()[4]" %}

extern "C" __global__ void {{kernel_name}}(
    const CArray<{{coords_type}}, {{coords_dims}}> coords,
    const CArray<{{coeffs_type}}, {{coeffs_dims}}> coeffs,
    const CArray<{{noll_index_type}}, {{noll_index_dims}}> noll_index,
    CArray<{{out_type}}, {{out_dims}}> ddes)
{
    int chan = blockIdx.x*blockDim.x + threadIdx.x;
    int ant = blockIdx.y*blockDim.y + threadIdx.y;
    int time = blockIdx.z*blockDim.z + threadIdx.z;
    int npoly = coeffs.shape()[coeffs.ndim - 1];

    if(time >= {{ntime}} || ant >= {{na}} || chan >= {{nchan}})
        { return; }

    int coord_stride = {{nsrc}}*{{ntime}}*{{na}}*{{nchan}};

    __shared__ struct {
        {{coeffs_type}} coeffs[{{blockdimz}}][{{blockdimy}}][{{blockdimx}}][{{npoly}}][{{corrs}}];
        {{noll_index_type}} noll_index[{{blockdimz}}][{{blockdimy}}][{{blockdimx}}][{{npoly}}][{{corrs}}];
    } shared;

    for(int src=0; src < {{nsrc}}; ++src)
    {
        int i = ((src*{{ntime}} + time)*{{na}} + ant)*{{nchan}} + chan;
        {{coords_type}} l = coords[coord_stride*0 + i];
        {{coords_type}} m = coords[coord_stride*1 + i];
        // {{coords_type}} freq = coords[coord_stride*2 + i];

        {{coords_type}} rho = {{sqrt_fn}}(l*l + m*m);
        {{coords_type}} phi = {{atan2_fn}}(l, m);

        for(int poly=0; poly < npoly; ++poly)
        {

        }
    }
}
